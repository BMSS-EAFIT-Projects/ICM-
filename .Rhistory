false_alarms[sim, j]  <- 0
delay_results[sim, j] <- tau - (theta - m)
}
}
}
# calcular métricas
p_fa       <- colMeans(false_alarms)
mean_delay <- colMeans(delay_results, na.rm = TRUE)
results_list[[i]] <- data.frame(
scenario      = names(results_list)[i],
threshold     = h_vals,
p_false_alarm = p_fa,
mean_delay    = mean_delay,
log_delay     = log10(1 + mean_delay)
)
}
# combinar resultados
do.call(rbind, results_list)
}
# --- EJEMPLO DE USO ---
# definir los 3 escenarios
scenarios <- list(
list(theta = 300, mu1 = 1),
list(theta = 300, mu1 = 1.5),
list(theta = 300, mu1 = 2)
)
# lanzar simulación
res_df <- montecarlo_multi(
n_sim     = 100,
h_vals    = seq(1, 6, 0.5),
scenarios = scenarios,
m         = 200,
ncm_fun   = Non_conformity_KNN,
bet_fun   = Mixture_Betting_Func
)
# preparar colores
sc_names <- unique(res_df$scenario)
cols     <- c("red", "blue", "darkgreen")[seq_along(sc_names)]
# plot superpuesto
plot(NULL,
xlim = range(res_df$p_false_alarm),
ylim = range(res_df$log_delay, na.rm = TRUE),
xlab = "Probabilidad de Falsa Alarma",
ylab = "log10(1 + Retardo Medio)",
main = "Comparación de Escenarios ICM")
grid()
for (i in seq_along(sc_names)) {
sub <- subset(res_df, scenario == sc_names[i])
lines(sub$p_false_alarm,
sub$log_delay,
type = "b",
pch  = 19,
col  = cols[i])
}
legend("topright",
legend = sc_names,
col    = cols,
pch    = 19,
title  = "Escenarios")
# Vector de meses en español en el orden correcto
meses <- c("Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio",
"Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre")
# Limpiar nombres de columnas por si hay espacios
colnames(Series) <- trimws(colnames(Series))
# Asegurar que 'Año' es numérico
datos <- Series %>%
mutate(Año = as.numeric(Año))
# Transformar a formato largo y construir fecha
datos_largos <- Series %>%
pivot_longer(cols = all_of(meses), names_to = "Mes", values_to = "valor") %>%
mutate(
Mes = factor(Mes, levels = meses),               # para asegurar el orden
mes_num = as.integer(Mes),                       # convertir a número de mes
fecha = make_date(year = Año, month = mes_num, day = 1),
valor = ifelse(valor == -99, NA, valor)          # convertir -99 a NA
) %>%
select(Planta, Nombre, fecha, valor) %>%
arrange(Planta, Nombre, fecha)
serie <- datos_largos %>%
filter(Planta == "ALTO ANCHICAYA", Nombre == "Alto Anchicaya")
ggplot(serie, aes(x = fecha, y = valor)) +
geom_line() +
labs(
title = "Serie mensual - Alto Anchicaya",
x = "Año",
y = "Valor"
) +
scale_x_date(date_labels = "%Y", date_breaks = "2 years") +
theme_minimal() +
theme(axis.text.x = element_text(angle = 45, hjust = 1))
entrenamiento_achicaya <- serie %>% slice(1:75)
serie_de_tiempo_anchicaya <- serie %>% slice(76:n())
Cn <- IMC(entrenamiento_achicaya$valor, serie_de_tiempo_anchicaya$valor, ncm = Non_conformity_KNN, betting_function = Mixture_Betting_Func, k = ceiling(75/2))
plot(Cn$Cn, type = "l", main = "Cn",
xlab = "Tiempo", ylab = "Cn", col = "blue")
#abline(v = 499, col = "red", lty = 2, lwd = 2)
abline(h = 1.5, col = "green", lty = 3, lwd = 2)  # Un valor h de umbral
ICM_MULTIPLE <- function(training_set, data, ncm, betting_function, th, k = 1, retrain_size = NULL) {
eps <- .Machine$double.eps
N <- length(data)
change_points <- integer(0)
start_idx     <- 1
while (start_idx < N) {
# Datos de la ventana actual
window_data <- data[start_idx:N]
M <- length(window_data)
# Preparamos vectores para monitoring window alphas, p-values y Cn
alphas   <- numeric(M)
p_vals   <- numeric(M)
Cn_vec   <- numeric(M)
# Reinicializamos martingale para esta ventana de monitoreo
S       <- 1
min_S   <- 1
# Contador para el martingale (independiente del índice de ventana)
martingale_count <- 0
martingale_alphas <- numeric(M)  # Almacena solo los alphas para el cálculo del martingale
for (j in seq_len(M)) {
# 1) Calculamos el non-conformity score y lo guardamos
alphas[j] <- ncm(window_data[j], training_set, k = k)
# Incrementamos contador del martingale y almacenamos el alpha
martingale_count <- martingale_count + 1
martingale_alphas[martingale_count] <- alphas[j]
# 2) Calculamos p-valor basado SOLO en los alphas del martingale (no incluye training set)
if (martingale_count == 1) {
p_vals[j] <- runif(1)
} else {
mayores <- sum(martingale_alphas[1:martingale_count] > martingale_alphas[martingale_count])
iguales <- sum(martingale_alphas[1:martingale_count] == martingale_alphas[martingale_count])
u       <- runif(1)
p_vals[j] <- (mayores + u * iguales) / martingale_count
}
# 3) Actualizamos S con la función de apuesta
g_j <- betting_function(p_vals[j])
S     <- max(S * g_j, eps)
min_S <- max(min(min_S, S), eps)
# 4) Calculamos Cn
Cn_vec[j] <- log(S) - log(min_S)
# 5) Si supera umbral, registramos cambio y actualizamos entrenamiento
if (!is.na(Cn_vec[j]) && Cn_vec[j] > th) {
cp_global <- start_idx + j - 1
change_points <- c(change_points, cp_global)
# Actualizamos conjunto de entrenamiento con datos a partir del cambio detectado
if (is.null(retrain_size)) {
training_set <- window_data[j:M]  # todo lo que queda
} else {
end_retrain <- min(j + retrain_size - 1, M)
training_set <- window_data[j:end_retrain]
}
# Reiniciamos ventana desde el punto de cambio
start_idx <- cp_global
break
}
# 6) Si llegamos al final sin detección, forzamos fin de while
if (j == M) {
start_idx <- N
}
}
}
return(change_points)
}
set.seed(123)
resultados <- ICM_MULTIPLE(entrenamiento_achicaya$valor, serie_de_tiempo_anchicaya$valor, ncm = Non_conformity_KNN, betting_function = Mixture_Betting_Func, th =1.5 , k = ceiling(75/2))
indices <- resultados
fechas_lineas <- serie$fecha[indices]
fechas_lineas
fechas_lineas <- sort(fechas_lineas)
# Crear vector de rangos (inicio y fin)
rangos_inicio <- c(min(serie$fecha), fechas_lineas)
rangos_fin <- c(fechas_lineas, max(serie$fecha))
# Crear data frame con medias por tramo
segmentos_media <- purrr::map2_df(rangos_inicio, rangos_fin, ~ {
df_segmento <- serie %>% filter(fecha >= .x, fecha < .y)
if(nrow(df_segmento) > 0){
tibble(
fecha_inicio = min(df_segmento$fecha),
fecha_fin = max(df_segmento$fecha),
media = mean(df_segmento$valor, na.rm = TRUE)
)
} else {
NULL
}
})
# Graficar todo junto
p<-ggplot(serie, aes(x = fecha, y = valor)) +
geom_line() +
# Líneas verticales
geom_vline(xintercept = fechas_lineas, color = "red", linetype = "dashed", linewidth=1) +
# Etiquetas en líneas verticales
geom_text(
data = data.frame(fechas_lineas),
aes(x = fechas_lineas, y = max(serie$valor, na.rm = TRUE) + 5,
label = format(fechas_lineas, "%Y-%m")),
angle = 0, vjust = 0, hjust = -0.2, color = "black", size = 3
) +
# Líneas horizontales de medias por tramo
geom_segment(
data = segmentos_media,
aes(x = fecha_inicio, xend = fecha_fin, y = media, yend = media),
color = "red", linewidth = 1
) +
theme_minimal() +
labs(
title = "Serie mensual - Alto Anchicaya",
x = "Fecha",
y = "Valor"
)
p
entrenamiento_baseball <- mlb_diffs$hr_rate_diff[1:10]
serie_de_tiempo_baseball <- mlb_diffs$hr_rate_diff[11:length(mlb_diffs$hr_rate_diff)]
resultado <- IMC(entrenamiento_baseball, serie_de_tiempo_baseball, ncm = Non_conformity_KNN, betting_function = Mixture_Betting_Func, k = ceiling(10/2), th=3)
resultado
tible <- mlb_diffs
fechas_lineas <- mlb_diffs$yearID[51]
fechas_lineas
grafica_baseball <- ggplot(mlb_diffs, aes(x = yearID, y = hr_rate_diff)) +
geom_line() +
geom_vline(aes(xintercept = yearID[resultado], color = "ICM"), linetype = "dashed", size = 1) +
geom_vline(aes(xintercept = yearID[49], color = "Punto conocido"), linetype = "dashed", size = 1) +
scale_color_manual(
name = "Líneas",
values = c("ICM" = "red", "Punto conocido" = "blue")
) +
labs(
title = "Home Run Rate Difference Over Time",
x = "Year",
y = "HR Rate Diff"
) +
theme_minimal()
grafica_baseball <- ggplot(mlb_diffs, aes(x = yearID, y = hr_rate_diff)) +
geom_line() +
geom_vline(aes(xintercept = yearID[resultado$change_point], color = "ICM"), linetype = "dashed", size = 1) +
geom_vline(aes(xintercept = yearID[49], color = "Punto conocido"), linetype = "dashed", size = 1) +
scale_color_manual(
name = "Líneas",
values = c("ICM" = "red", "Punto conocido" = "blue")
) +
labs(
title = "Home Run Rate Difference Over Time",
x = "Year",
y = "HR Rate Diff"
) +
theme_minimal()
grafica_baseball
knitr::opts_chunk$set(echo = TRUE)
library(dplyr)
library(ggplot2)
# Si quisieras recrearlo todo “dinámicamente”:
source("../R/ncm_knn.R")
source("../R/betting_functions.R")
source("../R/icm_generic.R")
source("../R/montecarlo_icm.R")
kde_bf_fixed <- readRDS("../data/kde_bf_fixed.rds")
library(dplyr)
library(ggplot2)
# Si quisieras recrearlo todo “dinámicamente”:
source("../R/non_conformity_measures.R")
source("../R/betting_functions.R")
source("../R/icm_method.R")
source("../R/montecarlo_sims.R")
kde_bf_fixed <- readRDS("../data/kde_bf_fixed.rds")
# 1) Cargar funciones
source("R/ncm_knn.R")
# 1) Cargar funciones
source("R/non_conformity_measure.R")
# 1) Cargar funciones
source("R/non_conformity_measure.R")
# 1) Cargar funciones
source("R/non_conformity_measures.R")
source("R/betting_functions.R")
# 2) Definir parámetros de calibración
set.seed(2025)
m0          <- 200
n_calib     <- 1000
epsilon_cal <- 500
mu1_cal     <- 1
k0          <- ceiling(m0 / 2)
# 3) Generar training_set y calibration_data tal como en la Sección 2
train_for_kde <- rnorm(m0, 0, 1)
calib_stream  <- numeric(n_calib)
for (i in seq_len(n_calib)) {
idx_global <- m0 + i
if (idx_global < epsilon_cal) {
calib_stream[i] <- rnorm(1, 0, 1)
} else {
calib_stream[i] <- rnorm(1, mu1_cal, 1)
}
}
# 4) Ajustar la KDE y guardarla
kde_bf_fixed <- Precomputed_KDE_BF(
training_set           = train_for_kde,
calibration_data       = calib_stream,
non_conformity_measure = Non_conformity_KNN,
k                      = k0,
n_grid                 = 512
)
# 1) Cargar funciones
source("R/non_conformity_measures.R")
source("R/betting_functions.R")
# 2) Definir parámetros de calibración
set.seed(2025)
m0          <- 200
n_calib     <- 1000
epsilon_cal <- 500
mu1_cal     <- 1
k0          <- ceiling(m0 / 2)
# 3) Generar training_set y calibration_data tal como en la Sección 2
train_for_kde <- rnorm(m0, 0, 1)
calib_stream  <- numeric(n_calib)
for (i in seq_len(n_calib)) {
idx_global <- m0 + i
if (idx_global < epsilon_cal) {
calib_stream[i] <- rnorm(1, 0, 1)
} else {
calib_stream[i] <- rnorm(1, mu1_cal, 1)
}
}
# 4) Ajustar la KDE y guardarla
kde_bf_fixed <- Precomputed_KDE_BF(
training_set           = train_for_kde,
calibration_data       = calib_stream,
non_conformity_measure = Non_conformity_KNN,
k                      = k0,
n_grid                 = 512
)
# 5) Guardar la función en un archivo .rds para poder cargarla luego sin recalibrar
saveRDS(kde_bf_fixed, file = "data/kde_bf_fixed.rds")
library(dplyr)
library(ggplot2)
# Si quisieras recrearlo todo “dinámicamente”:
source("../R/non_conformity_measures.R")
source("../R/betting_functions.R")
source("../R/icm_method.R")
source("../R/montecarlo_sims.R")
kde_bf_fixed <- readRDS("../data/kde_bf_fixed.rds")
# 1) Cargar todas las funciones base
source("R/ncm_knn.R")
# 1) Cargar todas las funciones base
source("R/non_conformity_measures.R")
source("R/betting_functions.R")
source("R/icm_method.R")
source("R/montecarlo_sims.R")
# 2) Cargar la betting function precomputada (Generada por calibrar_kde.R)
kde_bf_fixed <- readRDS("data/kde_bf_fixed.rds")
# 3) Definir escenarios y parámetros
theta_vals <- c(100, 200)
mu1_vals   <- c(1, 1.5, 2)
h_vals     <- seq(1, 6, 0.5)
n_sim      <- 200
m          <- 200
k_par      <- 7
# 4) Ejecutar Monte Carlo en cada escenario y cada método
all_results <- list()
for (theta_s in theta_vals) {
for (mu1_s in mu1_vals) {
df_CBF <- montecarlo_ICM(
n_sim        = n_sim,
h_vals       = h_vals,
theta_stream = theta_s,
mu1          = mu1_s,
m            = m,
ncm_fun      = Non_conformity_KNN,
bet_fun      = Constant_BF,
k            = k_par
) %>% mutate(Method = "Constant BF")
df_MBF <- montecarlo_ICM(
n_sim        = n_sim,
h_vals       = h_vals,
theta_stream = theta_s,
mu1          = mu1_s,
m            = m,
ncm_fun      = Non_conformity_KNN,
bet_fun      = Mixture_BF,
k            = k_par
) %>% mutate(Method = "Mixture BF")
df_KDEF <- montecarlo_ICM(
n_sim        = n_sim,
h_vals       = h_vals,
theta_stream = theta_s,
mu1          = mu1_s,
m            = m,
ncm_fun      = Non_conformity_KNN,
bet_fun      = kde_bf_fixed,
k            = k_par
) %>% mutate(Method = "Precomputed KDE BF")
combined <- bind_rows(df_CBF, df_MBF, df_KDEF) %>%
mutate(
theta_stream = factor(theta_stream, levels = theta_vals),
mu1          = factor(mu1,        levels = mu1_vals),
scenario_id  = paste0("θ=", theta_s, "_μ1=", mu1_s)
)
all_results[[paste0("θ=", theta_s, "_μ1=", mu1_s)]] <- combined
}
}
# 5) Concatenar y salvar
df_all_methods <- bind_rows(all_results, .id = "scenario_key")
saveRDS(df_all_methods, file = "data/resultados_sim.rds")
df_all_methods <- readRDS("../data/resultados_sim.rds")
df_CBF <- df_all_methods %>% filter(Method == "Constant BF")
ggplot(df_CBF, aes(x = p_false_alarm, y = log_delay)) +
geom_line(color = "red", size = 1) +
geom_point(color = "red", size = 1) +
facet_grid(rows = vars(theta_stream), cols = vars(mu1),
labeller = labeller(
theta_stream = function(x) paste0("θ = ", x),
mu1          = function(x) paste0("μ₁ = ", x)
)) +
theme_minimal(base_size = 13) +
labs(
x     = expression(P[0](tau <= theta)),
y     = expression(log[10](1 + E[1][tau - theta ~|~ tau > theta])),
title = "ICM con Constant BF"
) +
theme(
strip.text.x     = element_text(size = 12, face = "bold"),
strip.text.y     = element_text(size = 12, face = "bold"),
panel.spacing    = unit(0.6, "lines"),
axis.text        = element_text(size = 10),
axis.title       = element_text(size = 12, face = "bold"),
plot.title       = element_text(size = 14, face = "bold")
)
df_CBF <- df_all_methods %>% filter(Method == "Constant BF")
ggplot(df_CBF, aes(x = p_false_alarm, y = log_delay)) +
geom_line(color = "red", size = 1) +
geom_point(color = "red", size = 1) +
facet_grid(rows = vars(theta_stream), cols = vars(mu1),
labeller = labeller(
theta_stream = function(x) paste0("θ = ", x),
mu1          = function(x) paste0("μ₁ = ", x)
)) +
theme_minimal(base_size = 13) +
labs(
x     = "(P[0](tau <= theta)",
y     = "log[10](1 + E[1][tau - theta ~|~ tau > theta]",
title = "ICM con Constant BF"
) +
theme(
strip.text.x     = element_text(size = 12, face = "bold"),
strip.text.y     = element_text(size = 12, face = "bold"),
panel.spacing    = unit(0.6, "lines"),
axis.text        = element_text(size = 10),
axis.title       = element_text(size = 12, face = "bold"),
plot.title       = element_text(size = 14, face = "bold")
)
df_MBF <- df_all_methods %>% filter(Method == "Mixture BF")
ggplot(df_MBF, aes(x = p_false_alarm, y = log_delay)) +
geom_line(color = "blue", size = 1) +
geom_point(color = "blue", size = 1) +
facet_grid(rows = vars(theta_stream), cols = vars(mu1),
labeller = labeller(
theta_stream = function(x) paste0("θ = ", x),
mu1          = function(x) paste0("μ₁ = ", x)
)) +
theme_minimal(base_size = 13) +
labs(
x     = expression(P[0](tau <= theta)),
y     = expression(log[10](1 + E[1][tau - theta ~|~ tau > theta])),
title = "ICM con Mixture BF"
) +
theme(
strip.text.x     = element_text(size = 12, face = "bold"),
strip.text.y     = element_text(size = 12, face = "bold"),
panel.spacing    = unit(0.6, "lines"),
axis.text        = element_text(size = 10),
axis.title       = element_text(size = 12, face = "bold"),
plot.title       = element_text(size = 14, face = "bold")
)
df_MBF <- df_all_methods %>% filter(Method == "Mixture BF")
ggplot(df_MBF, aes(x = p_false_alarm, y = log_delay)) +
geom_line(color = "blue", size = 1) +
geom_point(color = "blue", size = 1) +
facet_grid(rows = vars(theta_stream), cols = vars(mu1),
labeller = labeller(
theta_stream = function(x) paste0("θ = ", x),
mu1          = function(x) paste0("μ₁ = ", x)
)) +
theme_minimal(base_size = 13) +
labs(
x     = "(P[0](tau <= theta)",
y     = "(log[10](1 + E[1][tau - theta ~|~ tau > theta])",
title = "ICM con Mixture BF"
) +
theme(
strip.text.x     = element_text(size = 12, face = "bold"),
strip.text.y     = element_text(size = 12, face = "bold"),
panel.spacing    = unit(0.6, "lines"),
axis.text        = element_text(size = 10),
axis.title       = element_text(size = 12, face = "bold"),
plot.title       = element_text(size = 14, face = "bold")
)
df_KDEF <- df_all_methods %>% filter(Method == "Precomputed KDE BF")
ggplot(df_KDEF, aes(x = p_false_alarm, y = log_delay)) +
geom_line(color = "darkgreen", size = 1) +
geom_point(color = "darkgreen", size = 1) +
facet_grid(rows = vars(theta_stream), cols = vars(mu1),
labeller = labeller(
theta_stream = function(x) paste0("θ = ", x),
mu1          = function(x) paste0("μ₁ = ", x)
)) +
theme_minimal(base_size = 13) +
labs(
x     = "P[0](tau <= theta)",
y     = "log[10](1 + E[1][tau - theta ~|~ tau > theta])",
title = "ICM con Precomputed KDE BF"
) +
theme(
strip.text.x     = element_text(size = 12, face = "bold"),
strip.text.y     = element_text(size = 12, face = "bold"),
panel.spacing    = unit(0.6, "lines"),
axis.text        = element_text(size = 10),
axis.title       = element_text(size = 12, face = "bold"),
plot.title       = element_text(size = 14, face = "bold")
)
